---
layout: post
title: PTX Hello World
description: A really simple handwritten PTX file for learning CUDA
categories: tutorial
---

Below we show a small Parallel Thread Execution (PTX) in a CUDA kernel, and explain how it works.

```c++
// main.cu
#include <iostream>

__global__ void add_kernel(int a, int b, int* result) {
    int sum;
    asm("add.s32 %0, %1, %2;" : "=r"(sum) : "r"(a), "r"(b));
    *result = sum;
}

int main() {
    int a = 2, b = 3, result = 0;
    int* d_result;
    cudaMalloc(&d_result, sizeof(int));
    add_kernel<<<1,1>>>(a, b, d_result);
    cudaMemcpy(&result, d_result, sizeof(int), cudaMemcpyDeviceToHost);
    printf("Result: %d\n", result);
    cudaFree(d_result);
    return 0;
}
```

This is compiled and runs via:

```sh
nvcc main.cu -o main.bin && ./main.bin
# -> Result: 5
```

Looking at the code, we see the simple kernel that adds two 32 bit ints, a and b, and stores results in int pointer `result`. 

For the un-initiated, this `asm(...)` syntax looks weird:

```c++
__global__ void add_kernel(int a, int b, int* result) {
    int sum;
    asm("add.s32 %0, %1, %2;" : "=r"(sum) : "r"(a), "r"(b));
    *result = sum;
}
```

This `asm` allows for inserting assembly directly into the C/C++ code. Syntax for `asm` looks like this:

```c++
asm("assembly code" : output_operands : input_operands : clobbers);
```

Where `"assembly code"` is the PTX, `output_operands`, `input_operands` allow us to use our variables inside PTX, and clobbers are optional (think of clobbers as a scratchpad space).

The `add.s32 %0, %1, %2` PTX command adds two 32 bit integers `%1 %2` and stores result to `%0`. The `.s32` suffix means the operands and result are **signed 32-bit integers**. 

The `"=r"(sum)` says that variable `sum` acts as an output (`=` part) and that the variable shold be stored on a register (`r` part). The syntax then looks like `"=r"(sum)`.

The `"r"(a), "r"(b)` means that variables a and b are also used (both on a register) and they are not written to.